package 封装继承多态;

public class 多态 {
    /*
    * 一：方法的多态
    * 1.方法重载体现多态：传递不同的参数，即可调用不同的方法
    *
    * 2.方法重写体现多态：
    *
    * 二：对象的多态（多态的核心）
    * 总结：①一个对象的编译类型和运行类型可以不一致
    *       （父类的引用可以调用子类的对象——
    *         原理可以查看子类创建对象的运行机制是从父类依次下来的）
    *      ②编译类型在定义对象时就确定了，不能改变
    *      ③运行类型是可以变化的
    *      ④编译类型是 =坐标，=右边是运行类型  编译类型 = 运行类型
    *
    * 三：多态的向上转型：父类的引用指向了子类的对象
    *
    * 四：多态的向下转型：子类的引用指向了父类（子类强转）的引用（不是对象）
    *     向下转型的前置条件：要求它的前置条件是向上转型
    *
    * 其他:方法有重写之说，属性没有重写之说，如果父类引用子类的对象，
    * 子类和父类中都有相同的属性，则所调用的属性是父类的
    *
    * 五.instanceof //typeof 判断对象的运行类型是否匹配某类型的类型或子类型
    * */
    public static void main(String[] args) {
        C c = new A();
        c.GetBase();

        //向下转型（转的是C类的引用），编译的类型变成了A，运行类型也是A
        A a = (A)c;
        //这个时候就可以调用a中的方法了
        a.GetFather();

        //调用的是运行类型的A类GetBase重写方法，而不是C类的
        //但是new的对象不能调用子类当中的方法

        //能不能调用是由编译器决定的，所以父类不可调用子类的方法
        //但运行时如果调用的是父类的重写方法那么默认会从子类开始查找
        //所以所调用的重写方法是从子类开始的

        System.out.println(a instanceof A);//true
        System.out.println(a instanceof C);//true
    }

}
